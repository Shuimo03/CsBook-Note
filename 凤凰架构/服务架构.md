## 服务架构

### 原始分布式架构(优缺点)

这个时期的计算机处理能力较弱，为了提高处理能力，就提出了多台计算机共同协作来提升处理能力。

但是这样带来的问题在于，多机之间如何通信？如何调用它们的硬件。

#### 网络运算结构

#### AFS

#### LPC

#### RPC

### 单体系统时代(Monolithic 单体架构)(优缺点)

微服务并不是一种最优解，单体架构也不并不是一种落后的思想。而是要根据具体的业务来决定使用什么架构。

单体架构对于小型系统来说，只需要单台服务器就可以支撑软件系统，并且它容易开发，容易测试和部署。同时系统内的每个模块，功能，方法的调动过程都是在进程内调用。不会发生进程间通信。

单体架构是可以拆分分层的，不管是单体服务或者微服务等等，都是可以纵向层次划分。比较经典的MVC架构：

+ model
+ view
+ controller

收到之后的数据在不同层之间以不同的形式的数据结构进行流传递，最后传送给数据库，数据库在进行响应。

**todo 此处该有例子**

单体架构也可以按照横向划分，按照不同的技术，功能，职责等等。将软件拆分为各种模块，以便重用和管理代码。单体系统并不意味着只能有一个整体的程序封装形式，如果需要，它完全可以由多个 JAR、WAR、DLL、Assembly 或者其他模块格式来构成。

单体架构的缺陷在于拆分之后的隔离和自治能力，所有的代码都运行在同一个进程空间里面，这样的好处就是不需要考虑网络分区，对象复制等等。

但是也会带来一些坏处，过度消耗进程中的资源，同时某个功能造成的错误也是全局性的，比如：

+ 内存泄漏
+ 线程爆炸
+ 阻塞
+ 死循环

如果消耗的还是公共资源，譬如端口号或者数据库连接池泄漏，影响还将会波及整台机器，甚至是集群中其他单体副本的正常工作。

并且单体架构没有办法做到单独停止，更新，升级某一个部分功能，如果要做版本更新就必须整个程序都停下来。

### SOA架构(优缺点)

为了对大型的单体系统进行拆分，让每一个子系统都能够独立运行，部署，更新等等。这里提供三种有代表的架构模式：

+ 烟囱式架构
+ 微内核架构
+ 事件驱动架构

SOA架构带来的概念与思想：

+ 松散耦合
+ 注册
+ 发现
+ 治理
+ 隔离
+ 编排

### 微服务架构(优缺点)

微服务是指一种通过多个小形服务组合来构建单个应用的架构，这些服务围绕着业务能力而不是技术标准来构建。

每个服务可以使用不同的编程语言，不同的数据存储，运行在不同的进程之间，服务之间使用轻量级的通信机制和自动化部署机制来实现通信和运维。

**todo该有例子**

#### 康威定律

微服务的业务与技术特征：

+ 围绕业务能力构建
+ 分散治理
+ 通过服务来实现独立自治的组件
+ 产品化思维
+ 数据去中心化
+ 强终端弱管道
+ 容错性设计
+ 演进式设计
+ 基础设施自动化

#### 关键词

+ 注册发现
+ 跟踪治理
+ 负载均衡
+ 传输通信
+ 认证授权
+ 伸缩扩展
+ 事务处理
+ 降级熔断

### 后微服务架构(Cloud Native)

#### 关键词

+ 伸缩扩容
+ 虚拟化
+ 容器化
+ 软件定义网络
+ 软件定义存储

#### 存储

+ HDFS
+ Spark
+ chronos
+ flink

#### 容器编排

+ docker
+ Kubernetes

### 服务网格

### 无服务时代(Serverless)

无服务以简单为主要卖点，主要涉及两个部分：后端设施和函数

+ 后端设施：指数据库，消息队列，日志，存储，等等支持一些用来支持业务逻辑运行，但是本身无业务含义的技术组件，这些都运行在云上。在无服务中称为“后端即服务”。
+ 函数：指的是具体的业务代码，而函数的概念与粒度都已经非常接近程序编码角度的函数，其中区别是无服务中的函数运行在云端，不需要考虑算力问题，容量规划。无服务中称其为“函数即服务“。

无服务的设计初衷是为了让开发者只关心业务，不用考虑后端设施，后端的技术都是现成的。可以直接拿来使用，不需要去考虑采购、版权和选型的烦恼以及如何部署。

