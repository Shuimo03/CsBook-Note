## MySQL逻辑架构

+ 客户端：并不是MySQL独有的，大部分基于网络的CS结构都可以实现。
+ 线程

### 存储引擎

### 优化与执行

优化器并不关心表使用的是什么存储引擎，但是存储引擎对优化查询是有影响的，对于select语句，在执行之前，服务器会先检查查询缓存，如果能在缓存里面找到对应的查询，服务器就不用执行查询解析，优化和执行的整个过程，而是直接返回查询缓存中的结果集。

### 并发控制

### 读写锁

在处理并发读或写的时候，可以实现一个由两种类型组成的锁系统来解决问题，这两种类型的锁通常被称为共享锁和排他锁，也就是读锁和写锁。

读锁是共享的，也就是说是不会引起阻塞的，多个线程或者客户在同一时刻可以同时读取同一个资源而不互相干扰，写锁则是排他的，也就说一个写锁会阻塞其他的写锁和读锁。

写锁的优先级要比读锁高，所以一个写锁请求可能会被插入道读锁队列前面，而读锁不可以。

## 锁粒度

### 表锁

表锁是MySQL中最基本的锁策略，并且是开销最小的策略，它会锁定整张表。

### 行级锁

### 事务

数据库中的事务就是一组原子性的SQL查询，或者说是一个独立的工作单元，一个事务只存在两种状态，要不全部发生或者全部不发生。

### ACID

一个好的事务是遵守ACID的，而ACID分别代表着是：

+ 原子性(Atomicity)
+ 一致性(Consistency)
+ 隔离性(Isolation)
+ 持久性(Durability)

#### 原子性

一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。

#### 一致性

#### 隔离性

#### 持久性

#### 持久性级别

### 隔离级别

在SQL标准中定义了四种隔离级别：

+ 未提交读
+ 提交读
+ 可重复读
+ 可串行化

MySQL**默认的事务级别是可重复读**

### 脏读

### 幻读

### 死锁

数据库中的死锁是指两个或者更多的事务在同一个资源上相互占用，并且请求锁定对方的占用资源，从而导致恶性循环的现象。

innoDB目前解决解决死锁的方法就是将持有最少行级排他锁的事务进行回滚。

### MySQL中的事务

MySQL默认采用自动提交模式，

### 两段锁协议

## 多版本并发控制(MVCC)

+ 乐观并发控制
+ 悲观并发控制

## MySQL存储引擎

+ InnoDB
+ MyISAM

### InnoDB

InnoDB是MySQL默认的事务存储引擎，它被设计用来处理大量的短期事务，InnoDB使用MVCC来支持高并发，并且实现了四个标准的隔离级别，其默认级别是可重复读。

### MyISAM

MyISAM是MySQL5.1以及之前版本的默认存储引擎，MyISAM提供了大量的特性：

+ 全文索引
+ 压缩
+ 空间函数等等

MyISAM不支持事务和行级锁，而且崩溃之后没有办法安全恢复。

#### MyISAM特性

+ 加锁与并发
+ 修复
+ 索引特性

## 如何选择适合的引擎

从以下几个特性出发考虑

+ 事务
+ 备份
+ 崩溃恢复
+ 特有的性质

