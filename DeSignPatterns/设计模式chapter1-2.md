# chapter1引言

## 什么是设计模式

每一个模式都在描述不断重复发生的问题，以及解决该问题的解决方案核心，这样的话，就能一次又一次的使用该方案，而不用做重复的劳动。

举个栗子来说，就是一直重复的开发，可以用一套设计模式来解决。

一个模式有四个基本元素

1. 模式名
2. 问题
3. 解决方案
4. 效果

## MVC模式

MVC包括三类对象

- Model 模型是应用对象
- View 是显示出来的对象
- Controller 定义用户界面对用户输入响应方式

![Model–view–controller - Wikipedia](https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/MVC-Process.svg/1200px-MVC-Process.svg.png)

如果应用在web当中，view可以理解成为前端页面，也就是见到的东西，model是模型，解决问题的模型，controller是后端，view对应model的输出，controller对应的model的输入，举个栗子，随便打开一个网站，网站显示出来的就是view，如果这个时候需要去改变一些数据，只需要去改变controller就行了。

## 描述设计模式

首先需要同时记录设计产生的决定过程，选择过程和权衡过程，同时也需要一些具体例子。

1. 模式名和分类
2. 意图
3. 别名
4. 动机
5. 适用性
6. 结构
7. 参与者
8. 协作
9. 效果
10. 实现
11. 代码示例
12. 已知应用
13. 相关模式

## 23种设计模式

1. Abstract Factory 抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，不需要指定它们具体的类。
2. Adapter 适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作。
3. Bridge 桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立的变化。
4. Builder 生成器模式：将一个复杂对象的构建与它的表示分离，使得同样的构造过程可以创建不同的表示。
5. Chain of Responsibility 职责链模式：解除请求的发送和接收者之间的耦合，使多个对象都有机会处理这个请求，将这些对象连城一条链，并且沿着这条链传递该请求，直到有一个对象处理它。
6. Command 命令模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
7. Composite：将对象组合成树形结构以表示部分-整体的层次结构，Composite使得客户对单个对象和组合对象的使用具有一致性。
8. Decorator 装饰模式：动态地给一个对象添加一些额外的职责，就扩展功能而言，decorator模式比生成子类方式更加灵活。
9. Facade 外观模式：为子系统中的一组接口提供一个一致的界面，facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
10. Factory Method 工厂方法模式：定义一个用户创建对象的接口，让子类决定将那一个类实例化，Factory Method使一个类的实例化延迟到其子类。
11. Flyweight 享元模式：运用共享技术有效地支持大量细粒度的对象。
12. Interpreter 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
13. Iterator 迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象内部表示。
14. Mediator 中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
15. Memento 备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到保存状态。
16. Observer 观察者模式：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变的时候，所有依赖于它的对象都得到通知并自动刷新。
17. Prototype 原型模式：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。
18. Proxy 代理模式：为其他对象提供一个代理以控制对这个对象的访问。
19. Singleton 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
20. State ：允许一个对象在其内部状态改变它的行为，对象看起来似乎修改了它所属的类。
21. Strategy 策略模式：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换，本模式使得算法的变化可独立于使用它的客户。
22. Template Method ：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。
23. Visitor 访问者模式：表示一个作用于某对象结构中各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

## 设计模式分类

设计模式通过目的准则和范围准则分类，范围准则主要是指用于类还是用于对象，设计模式根据目的准则可以分为三种

1. 创建型
2. 结构型
3. 行为型

### 创建型

创建型是处理对象创建的设计模式，创建型模式主要是由两个主导思想构成，一是将系统使用的具体类封装起来，二十隐藏这些具体类的实例创建和结合的方式。

1. 简单工厂模式
2. 工程方法模式
3. 抽象工厂模式
4. 单例模式
5. 生成器模式
6. 原型模式

### 使用创建型设计模式的场景

- 一个系统需要和它的对象和磁盘的创建相互独立。
- 一组相关的对象被设计为一起使用。
- 隐藏一个类库的具体实现，仅展示它的接口。
- 创建独立复杂对象的不同表示。
- 一个类希望它的子类实现它所创建的对象。
- 类的实例化在运行的时候才被指定。
- 一个类只能有一个实例，而且这个实例能在任何时候被访问到。
- 实例应该能在不修改的情况下具有可扩展性。

### 结构型

结构型模式描述是如何将类或者对象结合在一起形成更大的结构，就像搭积木或拼图，可以通过简单的模具来组成复杂和功能更为强大的结构，结构型模式可以分为类结构模式和对象结构模式。

- 类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。
- 对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。

1. 外观模式
2. 适配器模式
3. 桥接模式
4. 代理模式
5. 装饰者模式
6. 享元模式

### 行为型

行为型模式是对在不同的对象之间划分责任和算法的抽象化，行为型模式不仅可以关注类和对象的结构，重点关注在它们之间的相互作用，通过行为型模式，可以更加清楚的划分类和对象的职责，并研究系统在运行时的实例对象之间的交互。

1. 责任链模式
2. 命令模式
3. 解释器模式
4. 迭代器模式
5. 中介者模式
6. 备忘录模式
7. 观察者模式
8. 状态模式
9. 策略模式
10. 模板方法模式
11. 访问者模式

### 设计模式如何解决设计问题

1. 寻找合适的对象
2. 决定对象的粒度
3. 指定对象接口
   1. 操作结构
   2. 对象接口
   3. 类型(一个对象可以有很多类型，不同的对象可以共享一个类型)
4. 描述对象的实现
5. 运用复用机制

对接口编程，而不是对实现编程。

### 扩展

- 面向对象设计
- 多态
- 动态绑定
- 抽象类和接口类
- 复用机制
  - 类继承
  - 对象组合
- 白箱复用
- 黑箱复用
- 封装性
- 委托
- 聚合
- 相识
- 耦合
- 应用程序设计模式
- 工具箱设计模式
- 框架设计模式

### 白箱复用

类继承允许编写代码的人根据其他类来定义一个类的实现，这个就被称为白箱复用，例如B复用A的功能，并且B可以了解到A的内部细节。

### 黑箱复用

对象组合是类继承的另一种复用选择，对象组合要求被组合的对象具有良好的定义接口，这种复用风格被称为黑箱复用，因为对象的内部细节是不可见的，也就说如果B类想复用A类的功能，而是把A类的对象变成B类的成员数据。

# chapter2