# 设计模式chapter2

## 实践案例-Lexi文档编辑器

### 设计问题

1. 文档结构
2. 格式化
3. 修饰用户界面
4. 支持多种视感标准
5. 支持多种窗口系统
6. 用户操作
7. 拼写检查和连字符

支持多种窗口系统有点类似于自适应，不同的屏幕尺寸显示不同的样子。

### 文档结构

文档的逻辑结构是句子、段落、节、小节和章，文档结构的内部如下几点

- 保持文档的物理结构，即将文本和图形安排到行，列，表等。
- 可视化地生成和显示文档。
- 根据显示位置来映射文档内部表示的元素。

### 递归组合

层次结构的信息表达通常是使用递归组合来实现，递归组合可以通过比较简单的元素逐渐建立起复杂的元素，每一个重要的元素可以表示成一个对象，就可以描述这种物理结构，不仅包括可见元素，还包括不可见元素。

### 使用递归组合的例子和好处

假设一个购物系统，下单买东西就会产生订单，订单中有各种各样的信息，比如包含无包装的简单产品，也可以是包含装满产品的盒子，如果要计算每张订单中的总价格的话，可以通过打开所有的盒子，然后找到里面所有的产品，最后计算出总价，现实生活中可以这样做，但是在写代码的时候，不能简单的去使用循环语句来完成这些工作，必须事先晓得所有的产品和盒子，以及这些信息，所以直接计算不方便。

这里就可以使用递归组合来解决这个问题，通过一个通用接口，然后让产品和盒子进行交互，并且在该接口中声明一个计算总价的方法(函数)。

对于一个产品，方法可以设计成直接返回价格，对于一个盒子，这个方法就遍历盒子中所有的产品，然后询问每个产品的价格，最后返回这个盒子的总价格，这样做的好处在于可以把具体类想象成一棵树，然后递归遍历这棵树，不需要去了解这棵树的形状，也不需要了解对象是简单的产品还是复杂的盒子，需要调用通用接口就可以使用相同的方式进行处理。

也是第一章提到的针对接口编程。

## 组合模式

组合模式的结构如下

1. 组件：接口描述树中简单项目和复杂项目的所共有的操作
2. 叶节点：是树的基本结构，不包含子项目，一般情况下
3. 容器/组合：是包含叶节点或者其他容器等子项目的单位，容器不知道其子项目所属的具体类，只通过通用的组件接口与子项目交互。
4. 客户端：通过组件接口和所有项目交互，所以客户端能以相同的方式与树状结构中的简单或复杂项目交互。

### 组合模式的优缺点

#### 优点

- 可以利用多态和递归的机制更方便的使用复杂的树形结构。
- 开闭原则，不需要改变现有的代码，就可以在应用中添加新元素，让它变成对象树的一部分。

#### 缺点

对于功能差异比较大的类，提供公共接口可能比较有困难，在特定的情况下，需要过度一般化组件接口，会变得让人难以理解。

## 策略模式

### 策略模式结构

- 上下文(Context)：维护只想具体策略的引用，并且通过策略接口与对象进行交流
- 策略(Strategy) 接口是所有具体策略的通用接口，它声明了一个上下文用于执行策略的方法。
- 具体策略(Concrete Strategies)：实现了上下文中所用的算法各种不同变体。
- 当上下文需要运行算法的时候，会在其已连接的策略对象上调用执行方法，上下文不清楚其所涉及的策略类型和算法的执行方式
- 客户端(Client)

### 策略模式应用

策略模式应用的关键点在于为它的环境设计足够通用的接口，是一种行为设计模式，能够让你设计定义一系列算法，并且将这些算法分别放入独立的类中，让算法的对象能够相互替换。

使用策略模式的时候，可以定义一些策略类，每个策略类中封装一种具体的算法，每个被封装的策略类被称为一种策略，根据传入不同的策略类，让环境类执行不同策略类中的算法。

举个栗子，比如说你设计一个图书馆管理系统，这个系统的核心功能是让用户查书/借书/还书，最开始的时候，这个管理系统设计成只学校的老师学生可以借书，但是作为一个非校内的图书馆，肯定还需要设计其他角色，接着又设计了这个区的人可以借书，但是随着规模扩大，你需要继续添加新的角色功能，终于在某一天你受不了，代码不能维护了，因为每次添加新的功能，都要导致主要类的体积增大。

不利于后期修改，修改某一个算法都会影响到其他的类，并且有新的程序员加入也会导致花很多时间解决合并冲突。

所以使用策略模式是可以解决这个问题，策略模式建议找出负责许多不同方式完成特定任务的类，然后将其中的算法抽取到一组被称为策略的独立类中，假设一个被称为上下文的原始类必须包含一个成员变量来存储每种策略的引用，但是上下文不执行任务，而是把任务交给已经连接的策略对象。

实际上，上下文并不是很了解策略，而是通过同样的通用接口和所有策略进行交互，这个接口只需要暴露一个方法来出发所选的策略中封装的算法就可以了。

所以，上下文可以独立于具体策略，这样就可以在不修改上下文代码或者其他策略的时候，添加新的算法或者修改已经有了的算法。

### 策略模式应用场景

- 当你想使用对象中各种不同的算法变体，并且相互能够在运行时切换算法的时候可以使用策略模式。
- 策略模式可以能够让对象关联到不同方式执行特定子任务的不同对象，从而以间接方法在运行的时候更改对象行为。
- 当有许多仅在执行某些行为的时候有一些不相同的相似类时，可以使用策略模式
- 策略模式能够让不同行为抽取到一个独立类层次结构中，并且将原始类组成为一个，减少重复代码。
- 策略模式能够将各种算法的代码、内部的数据和依赖关系和其他代码隔离开来，不同的客户端可以通过一个简单接口来执行算法，并且能够在运行时进行切换。
- 当类中使用了复杂运算符以在同一算法的不同变体中切换的时候，可以使用该模式
- 策略模式将所有继承自同样接口的算法抽取到独立类中，所以不需要调剂语句，原始对象不能实现所有算法的变体，而是把执行工作委派给其中一个独立算法对象。

### 策略模式优缺点

#### 优点

可以在运行时切换对象内的算法

可以将算法的实现和使用算法的代码隔离开

可以使用组合来替代继承

开闭原则，不需要对上下文修改就可以引入新的策略

#### 缺点

- 如果算法很少发生改变的话，那说明没有任何理由可以引入新的类和接口，使用这种模式只会让程序变的更复杂。
- 客户端必须要晓得策略之间的不同，它需要选择合适的策略。
- 许多现代编程语言支持函数类型的功能，允许你在一组匿名函数中实现不同版本的算法，这样的话，可以完全使用这些函数的方式和使用策略对象的时候完全一样，从而不需要额外接祖类和接口来保持代码简洁。

## 开闭原则 Open–closed principle