# 创造类型模式

创造类型模式抽象了实例化过程，提供了创建对象的机制，能够提升已有代码的灵活性和复用性，一个类创建型模式使用继承来改变被实例化的类，而一个对象创建型模式将实例化委托给另外一个对象。

## 创建型模式

1. 工厂方法：在父类中提供一个创建对象的接口来允许子类决定实例化对象的类型。
2. 抽象工厂：能够创建一系列相关对象，而不需要指定其具体类。
3. 生成器：能够分步骤创建复杂对象，该模式允许使用相同的创建代码生成不同类型和形式的对象。
4. 原型：能够复制已经有了的对象，从而不需要使代码依赖它们所属的类。
5. 单例：保证一个类只有一个实例，并且提供一个访问该实例的全局节点。

## 抽象工厂模式(Abstract-factory)

![img](https://alleniverson.gitbooks.io/design-pattern/content/assets/designpattern15.gif)

![抽象工厂模式示例的类图](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/example.png)

### 场景

假设你正在经营一家电器商场，电器商场里面有各种各样的问题，用代码类来表示的话：

- 一系列相关的产品，比如冰箱，洗衣机，电视等。
- 系列不同的变体和品牌，比如海尔冰箱，索尼电视等

你需要让每件电器单独生成对象，这样才能让风格保持一致，如果顾客买来发现风格不一样，可能就会不满意，另外也不希望添加新产品或者新的品牌的时候，修改现有代码，电器供应商如果对产品更新速度很快的话，你不会像每次更新都去修改关键代码。

### 解决方法

首先，抽象工厂模式建议为电器商场中所有的产品都声明接口，比如冰箱，洗衣机，电视等等，接着所有产品都继承这些接口，比如冰箱都实现冰箱接口等等。

接着声明抽象工厂，包括系列中所有产品构造方法的接口，比如创建电视createTv等等，这些方法必须返回抽象产品类型，每个具体工厂类对应一个特定的产品变体，对于系列产品的每个变体，都基于抽象工厂接口创建不同的工厂类，每个工厂类只能返回特定的产品，比如索尼品牌的电器，只能创建索尼电视，索尼冰箱，索尼洗衣机等等。

客户端代码可以通过相应的抽象接口来调用工厂和产品类，不需要改动实际客户端代码，就可以传递给客户端的工厂类，也能够修改客户端代码来接收产品变体，客户端不需要了解所调用工厂的具体类信息。

### 抽象工厂结构

![抽象工厂设计模式](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/structure-indexed.png)

1. 抽象产品：为构成系列产品的一组不同但是相关的产品声明接口
2. 具体产品：是抽象产品的多种不同类型实现，所有变体都必须实现相应的抽象产品。
3. 抽象工厂：接口声明一组创建各种抽象产品的方法。
4. 具体工厂：实现抽象工厂的构建方法，每个具体工厂对应特定产品变体，并且仅创建这种产品的而变体。

### 抽象工厂模式的优缺点

#### 优点

- 可以确保统一工厂生成的产品相互匹配
- 可以避免客户端和具体产品代码的耦合
- 单一职责原则，可以将产品生成代码抽取到同一位置，让代码更加容易维护。
- 开闭原则，向应用程序中引入新的产品变体时，不需要改变客户端代码

#### 缺点

因为采用该模式需要引入更多的接口和类，所以代码会更加复杂。

### 抽象工厂的应用场景

如果代码需要和多个不同系列的相关产品交互，但是因为没办法提前获取相关信息，或者处于对未来扩张性的考虑，不希望代码基于产品类进行构造，所以在这种情况下，就可以使用抽象工厂。

抽象工厂提供了一个接口，可以创建每个系列产品的对象，只需要代码通过这个结构创建对象，那么就不会生成和应用程序已经生成的产品类型不一样的产品。

假设有一个基于一组抽象方法的类，并且主要功能还变得不明确，就可以考虑使用抽象工厂模式，在设计良好的程序当中，每个类仅仅复制一件事，如果一个类需要和多种类型产品交互，就可以考虑工厂方法抽取到独立的工厂类或者具备完整功能的抽象工厂类中。

