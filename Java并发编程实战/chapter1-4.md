## 并发

### 并发概念

### 并行概念

### 异步概念

### 进程

### 进程间通信

+ 套接字
+ 信号处理器
+ 共享内存
+ 信号量
+ 文件等等

### 线程

线程也被称为轻量级进程，大多数操作系统中都是以线程作为调度单位，因为一个进程中所有线程都会共享进程中的内存地址空间，所以它们可以访问相同的变量并在同一个堆上面分配对象。

### 线程间通信

### 线程安全

当多个线程访问某个类的时候，不管运行时刻环境采用什么调度方式或者这些线程如何交替执行，并且在主调代码中不需要任何额外的同步或者协同，这个类就能表现出正确的行为，那么就称为线程安全的。

### 同步机制

+ synchronized
+ volatile
+ 显示锁
+ 原子变量

### 原子性

### 竞态条件

### 加锁机制

### 锁

- 悲观锁
- 乐观锁
- 自旋锁
- 适应性锁
- 偏向锁
- 轻量级锁
- 重量级锁
- 公平锁
- 非公平锁
- 可重入锁
- 非课重入锁
- 共享锁
- 排他锁

![img](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png)

### 乐观锁与悲观锁

对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定会有其他线程来修改数据，所以在操作数据之前需要先加锁，确保数据不会被别的线程修改。

举个例子，如果一个人想要去吃饭，为了防止别人抢他饭吃，他需要先对饭做一些保护措施，这种就是悲观锁。

Java中synchronized和Lock的实现类都是悲观锁。

乐观锁是认为自己在使用数据的时候不会被别的线程修改数据，所以就不会添加锁，只有在更新数据的时候才会去判断之前有没有其他线程来更新过这个数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作。

Java中通过无锁编程来实现乐观锁，最常用的是CAS算法，Java原子类中的递增操作就是通过CAS自旋实现的。

#### 使用场景

+ 悲观锁适合写操作多的场景，先加锁可以保证写操作的时候数据正确。
+ 乐观锁适合读操作多的场景，不加锁的特点可以让读操作的性能提升。

### CAS原理

CAS是一种无锁算法，在不使用锁的时候实现多线程之间的变量同步，并发包中的原子类就是通过CAS来实现乐观锁的。

CAS算法涉及到三个操作数

+ 需要读写的内存值V
+ 进行比较的值A
+ 惊醒比较的值B

当且仅当V等于A的时候，CAS通过原子方式用新值B来更新V值，比较+更新是一个原子操作，否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。

### CAS面临的问题

+ ABA问题
+ 循环时间长开销大
+ 只能保证一个共享变量的原子操作

### 自旋锁与适应性自旋锁

阻塞或者唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换会消费处理器时间，如果同步代码块里面的内容过于简单的话，状态转换消耗的时间有可能会比用户执行的时间还要长。

为了节省资源，我们会让当前操作系统进行自旋，如果在自选完成后前面缩影同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。

自旋锁不能替代阻塞，虽然自旋等待避免了线程切换的开销，但是它要占用处理器时间，如果锁被占用的时间很短，自旋等待的效果就很好，反之亦然。

自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。

而适应性自旋锁是不会固定次数，而是通过上次在同一个锁上的自旋时间以及锁的拥有着状态来决定的，如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

### 内存可见性

### 重排序

### synchronized

### volatile

### 非原子性的64位操作

当线程在没有同步的时候读取变量，可能会得到一个失效值，但至少这个值是在之前的某个线程设置的值，而不是一个随机值，这种安全性保证被称为最低安全性。

最低安全性适应绝大数变量，但是对非volatile类型的64位数值变量除外，因为Java内存模型要求，变量的读取和写入操作都必须是原子性的，但是

### ThreadLocal类

### Java内存模型

### 对象的组合