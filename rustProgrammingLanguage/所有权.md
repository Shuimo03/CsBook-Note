### 所有权

所有权（系统）是 Rust 最为与众不同的特性，它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全。

所有运行的程序都必须管理其使用计算机内存的方式。一般来说可以简单分为有GC和无GC的，有GC的比如Java/Go。在程序运行时不断地寻找不再使用的内存；在另一些语言中(C++/C)，程序员必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序。

### 堆与栈

栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 **指针**（*pointer*）。这个过程称作 **在堆上分配内存**（*allocating on the heap*），有时简称为 “分配”（allocating）。

入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。

访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。

当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。

### 堆和栈之间的区别

+ 栈放入的顺序是先后出，堆的是先进先出。
+ 栈中所有的数据都必须占用已知并固定的大小，在编译大小或者大小可能会变化的数据时会存放在堆上。
+ 入栈比在堆上分配内存要快，访问堆上的数据比访问栈上的数据慢，所以必须通过指针来访问。

### 所有权规则

1. Rust 中的每一个值都有一个被称为其 **所有者**（*owner*）的变量。
2. 值在任一时刻有且只有一个所有者。
3. 当所有者（变量）离开作用域，这个值将被丢弃。

### 内存与分配

对于 `String` 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：

- 必须在运行时向内存分配器（memory allocator）请求内存。(通用)
- 需要一个当我们处理完 `String` 时将内存返回给分配器的方法。(实现方法很多)

Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。

### Rust中的深拷贝与浅拷贝

###  `Copy` trait 

任何一组简单标量值的组合都可以实现 `Copy`，任何不需要分配内存或某种形式资源的类型都可以实现 `Copy` 。

+ 所有整数类型，比如u32。
+ 布尔类型
+ 所有浮点数类型。
+ 字符类型
+ 元组

### 引用与借用

引用的规则

+ 在任意给定时间，**要么** 只能有一个可变引用，**要么** 只能有多个不可变引用。
+ 引用必须总是有效的。

### 数据竞争

+ 两个或更多指针同时访问同一数据。
+ 至少有一个指针被用来写入数据。
+ 没有同步数据访问的机制

### Slice

另一个没有所有权的数据类型是 slice。slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。

字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出。