## 进程

### 进程定义

进程是对应用程序的抽象，每个进程都对应一个运行中的程序，有了进程的抽象，应用程序在运行时仿佛就占用了整个CPU，而不需要考虑什么时候把CPU让给其他应用程序。

进程的管理，CPU资源的分配任务都交给操作系统。

### 上下文切换

为了能够让多个进程同时进行，操作系统引入了上下文切换机制，通过保存和恢复进程在运行过程中的状态，让进程可以暂停、恢复和切换。从而实现CPU资源的共享。

同时配合虚拟内存机制，让每个进程都有独立的虚拟地址空间，让多个进程能够安全高效的共用物理资源。

### 进程状态

+ 新生态：进程刚被创建出来，还没完成初始化，不能被调度执行。
+ 预备态(就绪态)：进程可以被调度，但是还没有调度器选择，因为CPU的数量是少于进程量的，只有一部分进程能够被运行，其他可以被调度的都在预备态。
+ 运行态：表示进程正在CPU上运行，当一个进程执行一段时间后，调度器可以选择中断它的执行并重新返回调度队列。
+ 阻塞态：该状态表示进程需要等待外部事件(比如某个IO请求的完成)暂时还没有办法被调度，当进程的外部时间完成之后，它会迁移到预备状态。
+ 终止态：表示进程已经完成了执行，并且不会被调度。

### 进程

进程拥有独立的虚拟内存空间：

+ ### 用户栈：栈保存进程需要使用的各种临时数据，比如临时变量。

+ 代码库：进程的执行有时候依赖共享的代码库比如libc，这些代码库映射到用户栈下方的虚拟地址，并标记为只读。

+ 用户堆：堆管理的是进程动态分配的内存，和栈的扩展方向相反，堆是自底向上，堆顶在高地址上，当进程需要更多内存的时候，堆会向高地址扩展。

+ 数据与代码段

+ 内核部分

### 进程控制块

在内核中，每个进程都通过一个数据结构来保存它的状态：

+ 进程标识符(PID)
+ 进程状态
+ 虚拟内存状态
+ 打开的文件等等

这个数据结构被称为进程控制块(PCB)

### POSIX标准



## Linux案例分析

### 进程创建：fork

进程一般是通过调用fork接口来创建进程，从已经有的进程上创建出去。调用fork的进程被称为父进程，新创建的进程称为子进程，刚创建的时候两个进程的内存，寄存器，程序计数器等状态都完全一致。

但是它们是完全独立的两个进程，拥有不同的PID和虚拟内存空间，在fork完成之后会各自独立的执行，不会相互干扰。

### 进程执行：exec

### 进程监控：wait

### clone

### 僵尸进程

### 进程组和会话

### 进程管理

Linux第一个启动的进程是init，

### sleep和yield的区别

它们的共同点是都会让当前线程放弃CPU资源，交给其他线程执行。

## 线程

导入线程的原因如下：

+ 创建进程开销较大，需要完成创建独立的地址空间，载入数据和代码段，初始化堆等等。
+ 因为进程拥有的是独立的虚拟地址空间，在进程之间数据共享和同步比较麻烦。

而线程在进程内部添加可独立执行的单元，它们共享进程的地址空间，但又各自保存运行时所需要的状态，成为了操作系统调度和管理程序的最小单位。

### 多线程的地址空间布局

+ 分离内核栈和用户栈
+ 共享其他区域

### 用户态线程和内核态线程

内核态线程由内核创建，受操作系统调度器直接管理，而用户态线程是应用自己创建的，内核不可见，所以不直接受系统调度器管理。

和内核态线程相对比，用户态线程更加轻量级，创建开销也小，但是功能也受限。

### 多线程模型

+ 多对一模型
+ 一对多模型
+ 多对多模型

### 线程控制块与线程本地存储

## 纤程fiber

### 纤程的上下文切换

纤程的上下文切换触发机制和内核态不同，内核可以通过中断的方式抢占当前CPU进行上下文切换，这种切换是强制性的，所以也被称为抢占式多任务处理模式。

而纤程没有这种抢占其他纤程的权限，所以没有办法使用这种模式，但是纤程库一般提供yield接口，这个接口和一对一模型的yield接口类似。

都会暂时放弃CPU，允许其他纤程调度。

## 问题思考

+ 进程都有哪些状态？为什么要定义这些状态？
+ 进程的虚拟地址空间是怎么样的结构？
+ 进程如何进行上下文切换？
+ 为什么Linux要使用fork的方式创建进程？
+ 为什么需要写时拷贝技术？
+ fork和其他创建进程的方式有什么优点和缺点？
+ 进程树是周末方便操作系统进行管理的？
+ 为什么要引入线程？
+ 拥有多线程的进程的虚拟地址空间结构是怎么样的？
+ 用户态线程和内核态线程的区别和联系分别是什么？
+ 针对线程的核心操作有哪些？
+ 什么是纤程？如何使用纤程？
+ 纤程是怎么做到上下文切换的？
+ 纤程和进程线程有什么区别？

