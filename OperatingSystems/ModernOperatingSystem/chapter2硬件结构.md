### 硬件结构

现在主流的计算机硬件结构还是冯诺依曼结构，冯诺依曼结构分成三个部分：

+ 中央处理器(CPU)
+ 存储器
+ 输入输出

### 指令集架构(ISA)

这本书中的操作系统是基于AArch64体系结构，每条指令属于精简指令，长度固定4字节，指令类型：

+ 数据搬移指令(mov)
+ 寄存器计算指令(add mov)
+ 内存读写指令
+ 跳转指令
+ 过程调用指令
+ 特权指令

指令集结构组成：

+ 指令
+ 特权级
  + EL0：最低的特权级，应用程序通常运行在这个级别，也被称为用户态。
  + EL1：操作系统通常运行在这个级别，也被称为内核态。
  + EL2：在虚拟化场景下需要，虚拟机监控器通常运行在这个级别下。
  + EL3：和安全特性有关系。
+ 寄存器

指令集结构大概可以分成：

+ 精简指令集
+ 复杂指令集

### 特权级之间的切换

一般来说，EL0和EL1之间相互切换的频率很高，可能发生的场景是：

+ 应用程序需要调用操作系统提供的系统调用，这个时候应用通过执行svc指令将CPU特权级从EL0转换到EL1。
+ 应用程序执行一条指令，而这条指令出发了异常，该异常导致CPU特权级从EL0切换到EL1。
+ 应用程序在运行的过程中，CPU收到一个来自外设的中断，该中断会导致CPU特权级从EL0切换到EL1。

在发生特权级切换的时候，CPU负责保存当前执行的状态，这样方便操作系统内核在处理完异常之后能够从应用程序中恢复出来。

### 物理内存和CPU缓存

CPU可以通过指令直接访问物理内存，通过总线向物理内存发送一个读写请求，其中包括目标地址，如果是写请求还需要包括写入值。物理内存收到请求之后进行读写操作(如果是读操作的话，需要将读到的值返回给CPU)。

从CPU角度出发，可以把物理内存看作是一个由字节组成的大数组，其中每个字节拥有一个物理地址，CPU可以在这个数组里面存储数据。

目前来看没什么问题，CPU直接访问到内存，但是这样的访问速度很慢，跟不上CPU的处理速度，可能一条算术运算指令需要一个或者几个时钟周期就结束了，而一次内存的访问就可能花费上百个时钟周期。

为了降低CPU访存的开销，现在CPU引入了缓存(cache)，用来存放一部分物理内存中的数据，访问CPU缓存的速度要比直接访问内存的速度快很多。

当CPU需要向物理内存写入数据的时候，它可以直接写在CPU缓存之中，如果需要读取数据的时候，就先在CPU缓存中查找，没有查到的话就去物理内存中获取，然后把取回的数据存入缓存中，方便下次读取速度。

### 缓存结构

CPU缓存是若干个缓存行组成的，每个缓存行包括以下内容：

+ 一个有效位：用来表示是否有效
+ 一个标记地址：用来表示其对应的物理地址
+ 一些其他状态信息

### 设备与中断

### 轮询与中断

### 思考题

+ 为什么要引入CPU缓存？直接访问内存会带来什么问题？
+ CPU缓存的结构是怎么样的？
+ 如何访问CPU缓存？
+ 如何设计CPU缓存？
+ 怎么判断CPU缓存是否满了？以及每次需要淘汰什么样的信息？
+ CPU与设备直接交互的方式有哪些？
+ CPU可以通过轮询或中断获取设备的输入，它们的差异有哪些？分别适合那些场景？
+ 中断处理的流程是什么？
+ 从应用程序的角度出发，异常和中断的区别是什么？
