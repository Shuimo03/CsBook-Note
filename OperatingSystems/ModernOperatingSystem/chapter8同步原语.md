## 同步原语



## 互斥锁

### 临界区问题

假设一个场景，一个消费者和多个生产者，生产者需要把数据放入缓冲区。但是在多个生产者的时候如何保证能够正确的存放？这种情况最直接的方式就是在同一时刻只让一个生产者把数据放入到缓冲区内惊醒操作。

当它完成后就退出，让下个生产者再进去。这种任意时刻只允许一个线程访问的方式被称为互斥访问，而保证互斥访问共享资源的代码区域被称为临界区。

在临界区内，一个线程阔以安全的对共享资源进行操作，而如何通过设计协议来保证互斥访问临界区的问题就是临界区问题。为了解决临界区问题而设计的算法有三个目标：

+ 互斥访问：在同一个时刻，最多只有一个线程可以执行临界区。
+ 有限等待：当一个线程申请进入临界区之后，必须在有限的时间内获得许可并进入临界区，不能无限等待。
+ 空闲让进：当没有线程在执行临界区代码的时候，必须在申请进入临界区的线程中选择一个线程，允许执行临界区代码，保证程序执行进展。

### 硬件实现：关闭中断

### 软件实现：皮特森算法

经典的皮特森算法只能满足两个线程，并且皮特森算法要求访存操作要严格按照程序顺序执行，但是现代CPU为了达到更好的性能往往允许访存操作乱序执行。

所以皮特森算法无法直接在这些CPU上正确工作。

### 软硬结合：原子操作

原子操作是指不可被打断的一个或者一系列操作，要么全部执行，要么都不执行，不会出现到一半的状态，最常见的原子操作是：

+ CAS
+ FAA

### CAS实现

### FAA实现

## 互斥锁的实现

一把锁在同一时刻只能被一个线程拥有，一旦被某个线程获取了锁，那其他线程都不能同时拥有这个锁，只能等待被释放。互斥锁提供了两种操作：

+ 加锁
+ 解锁

为了保证临界区的互斥访问，在申请进入临界区的时候尝试获取共享的一把锁，只有拥有锁的线程才能执行临界区的代码，再退出的时候，线程会释放锁。让其他的线程来获取锁从而进入临界区。

### 自旋锁

自旋锁是通过CAS实现的，利用一个变量lock来表示锁的状态，lock等于1的时候表示已经有人拿锁，为0的时候表示锁空闲。在加锁的时候线程会通过CAS来判断lock是否空闲，如果空闲就上锁。如果不是的话就会一直申请锁。

### 排号自旋锁

排号自旋锁使用了一种更加公平的选择策略，排号锁按照锁竞争者申请锁的顺序传递锁，和现实生活中排队一样，排号锁的竞争者依次按照申请的先后顺序，分到一个排队序号。

排号锁一次按照序号，将锁传递给最先到达的竞争者。形成了一个先进先出的等待队列。

## 条件变量

条件变量是一种挂起/唤醒机制，它可以解决循环等待问题。循环等待会浪费CPU资源和增加系统的能耗。条件变量必须搭配一个互斥锁一起使用，该互斥锁用来保护对条件的判断和修改。

### 互斥锁和条件变量的对比

互斥锁和条件变量解决的不是同一个问题，互斥锁用来解决临界区问题，保持互斥访问共享资源，而条件变量通过提供挂起/唤醒来避免循环等待，节省CPU资源。条件变量需要和互斥锁搭配使用。

### 信号量(PV操作)

信号量在不同的线程之间充当信号灯，根据剩余资源数量控制不同线程的执行或等待。信号量用来辅助多个线程访问有限数据的共享资源，信号量只允许三个不同操作对其值进行修改，分别是初始化操作，wait操作和signal操作。

### 互斥锁对比信号量

互斥锁和信号量有类似的地方，当信号量的初值被设置为1，并且只允许该值在0和1之间变化的时候，wait和signal操作分别和互斥锁的lock和unlock操作类似。

这种称为二元信号量，二元信号量和互斥锁的差别在于：互斥锁有一个拥有者的概念，而二元信号量没有，互斥锁往往由统一个线程加锁和解锁，而信号量允许不同线程执行wait和signal操作。



## 问题

+ 当多个线程同时修改共享数据的时候，是否会发生错误？
+ 应该提供什么样的同步原语避免这一类的错误发生？
+ 如何正确的实现互斥锁？
+ 互斥锁的数量是有限的吗？能不能每次多让几个线程进入临界区？
+ 如何正确的使用跳久变量来避免循环等待？
+ 如何正确的实现条件变量？
+ 信号量和互斥锁有什么区别？