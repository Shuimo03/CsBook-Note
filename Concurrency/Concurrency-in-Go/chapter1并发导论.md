## 并发概念

## 并发锁遇到的问题

### 数据竞争

数据竞争的产生条件是并发错误类型最隐蔽的一种，因为它们可能是在代码投入运行后展示出来的。

### 原子性

原子性意味着"不可分割"和"不可中断"，原子性的东西在整个过程发生，而不会同时发生任何事情，通过下面的例子来观察下原子性:

```go
i++
```

i++并不一定是原子性操作，因为它至少有三个步骤：

+ 检查i的值。
+ i的值加一
+ 存储i的值

尽管这些操作每一个都是原子的，但是三者组合起来可能就不是了，取决于上下文。

### Go的Context

### 死锁

### 解决死锁的方法

科夫曼条件

+ 相互排斥：并发进程在任何时候都拥有资源的独占权。
+ 等待条件：并发进程必须同时持有资源并等待额外的资源。
+ 没有抢占：并发进程持有的资源只能由该进程释放，因此它满足了这种情况。
+ 循环等待：一个并发进程（P1）必须等待一系列其他并发进程（P2）。

以上一个条件不成立，就不会死锁。

### 活锁

### 饥饿

### 并发算法



### 思考

- 如何保证并发程序出现数据竞争？或者说保证一个执行顺序？
- 如何保证原子性？

